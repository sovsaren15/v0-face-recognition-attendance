{"ast":null,"code":"// Import face-api.js library\nimport * as faceapi from \"@vladmandic/face-api\";\n\n// Face-api.js utilities for face recognition\nexport const loadFaceApiModels = async () => {\n  const MODEL_URL = \"https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.14/model/\";\n  try {\n    await Promise.all([faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL), faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL), faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL), faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL)]);\n    console.log(\"Face API models loaded successfully\");\n    return true;\n  } catch (error) {\n    console.error(\"Error loading Face API models:\", error);\n    return false;\n  }\n};\n\n// Detect faces in an image\nexport const detectFaces = async input => {\n  try {\n    const detections = await faceapi.detectAllFaces(input, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptors().withFaceExpressions();\n    return detections;\n  } catch (error) {\n    console.error(\"Error detecting faces:\", error);\n    return [];\n  }\n};\n\n// Compare two face descriptors with threshold\nexport const compareFaces = (descriptor1, descriptor2, threshold = 0.6) => {\n  if (!descriptor1 || !descriptor2) return false;\n  const distance = faceapi.euclideanDistance(descriptor1, descriptor2);\n  return distance < threshold;\n};\n\n// Find best matching face\nexport const findBestMatch = (faceDescriptor, referenceDescriptors) => {\n  if (!faceDescriptor || !referenceDescriptors.length) return null;\n  let bestMatch = null;\n  let bestDistance = Number.POSITIVE_INFINITY;\n  referenceDescriptors.forEach(ref => {\n    const distance = faceapi.euclideanDistance(faceDescriptor, ref);\n    if (distance < bestDistance) {\n      bestDistance = distance;\n      bestMatch = {\n        distance,\n        index: referenceDescriptors.indexOf(ref)\n      };\n    }\n  });\n  return bestMatch && bestMatch.distance < 0.6 ? bestMatch : null;\n};\n\n// Convert tensor to array\nexport const descriptorToArray = descriptor => {\n  return Array.from(descriptor);\n};\n\n// Convert array to tensor\nexport const arrayToDescriptor = array => {\n  return new Float32Array(array);\n};","map":{"version":3,"names":["faceapi","loadFaceApiModels","MODEL_URL","Promise","all","nets","tinyFaceDetector","loadFromUri","faceLandmark68Net","faceRecognitionNet","faceExpressionNet","console","log","error","detectFaces","input","detections","detectAllFaces","TinyFaceDetectorOptions","withFaceLandmarks","withFaceDescriptors","withFaceExpressions","compareFaces","descriptor1","descriptor2","threshold","distance","euclideanDistance","findBestMatch","faceDescriptor","referenceDescriptors","length","bestMatch","bestDistance","Number","POSITIVE_INFINITY","forEach","ref","index","indexOf","descriptorToArray","descriptor","Array","from","arrayToDescriptor","array","Float32Array"],"sources":["D:/we_project/face-recognition/v0-face-recognition-attendance/frontend/src/services/faceRecognition.js"],"sourcesContent":["// Import face-api.js library\r\nimport * as faceapi from \"@vladmandic/face-api\"\r\n\r\n// Face-api.js utilities for face recognition\r\nexport const loadFaceApiModels = async () => {\r\n  const MODEL_URL = \"https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.14/model/\"\r\n\r\n  try {\r\n    await Promise.all([\r\n      faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),\r\n      faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),\r\n      faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),\r\n      faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),\r\n    ])\r\n    console.log(\"Face API models loaded successfully\")\r\n    return true\r\n  } catch (error) {\r\n    console.error(\"Error loading Face API models:\", error)\r\n    return false\r\n  }\r\n}\r\n\r\n// Detect faces in an image\r\nexport const detectFaces = async (input) => {\r\n  try {\r\n    const detections = await faceapi\r\n      .detectAllFaces(input, new faceapi.TinyFaceDetectorOptions())\r\n      .withFaceLandmarks()\r\n      .withFaceDescriptors()\r\n      .withFaceExpressions()\r\n\r\n    return detections\r\n  } catch (error) {\r\n    console.error(\"Error detecting faces:\", error)\r\n    return []\r\n  }\r\n}\r\n\r\n// Compare two face descriptors with threshold\r\nexport const compareFaces = (descriptor1, descriptor2, threshold = 0.6) => {\r\n  if (!descriptor1 || !descriptor2) return false\r\n\r\n  const distance = faceapi.euclideanDistance(descriptor1, descriptor2)\r\n  return distance < threshold\r\n}\r\n\r\n// Find best matching face\r\nexport const findBestMatch = (faceDescriptor, referenceDescriptors) => {\r\n  if (!faceDescriptor || !referenceDescriptors.length) return null\r\n\r\n  let bestMatch = null\r\n  let bestDistance = Number.POSITIVE_INFINITY\r\n\r\n  referenceDescriptors.forEach((ref) => {\r\n    const distance = faceapi.euclideanDistance(faceDescriptor, ref)\r\n    if (distance < bestDistance) {\r\n      bestDistance = distance\r\n      bestMatch = { distance, index: referenceDescriptors.indexOf(ref) }\r\n    }\r\n  })\r\n\r\n  return bestMatch && bestMatch.distance < 0.6 ? bestMatch : null\r\n}\r\n\r\n// Convert tensor to array\r\nexport const descriptorToArray = (descriptor) => {\r\n  return Array.from(descriptor)\r\n}\r\n\r\n// Convert array to tensor\r\nexport const arrayToDescriptor = (array) => {\r\n  return new Float32Array(array)\r\n}\r\n"],"mappings":"AAAA;AACA,OAAO,KAAKA,OAAO,MAAM,sBAAsB;;AAE/C;AACA,OAAO,MAAMC,iBAAiB,GAAG,MAAAA,CAAA,KAAY;EAC3C,MAAMC,SAAS,GAAG,iEAAiE;EAEnF,IAAI;IACF,MAAMC,OAAO,CAACC,GAAG,CAAC,CAChBJ,OAAO,CAACK,IAAI,CAACC,gBAAgB,CAACC,WAAW,CAACL,SAAS,CAAC,EACpDF,OAAO,CAACK,IAAI,CAACG,iBAAiB,CAACD,WAAW,CAACL,SAAS,CAAC,EACrDF,OAAO,CAACK,IAAI,CAACI,kBAAkB,CAACF,WAAW,CAACL,SAAS,CAAC,EACtDF,OAAO,CAACK,IAAI,CAACK,iBAAiB,CAACH,WAAW,CAACL,SAAS,CAAC,CACtD,CAAC;IACFS,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;IAClD,OAAO,IAAI;EACb,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdF,OAAO,CAACE,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;IACtD,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA,OAAO,MAAMC,WAAW,GAAG,MAAOC,KAAK,IAAK;EAC1C,IAAI;IACF,MAAMC,UAAU,GAAG,MAAMhB,OAAO,CAC7BiB,cAAc,CAACF,KAAK,EAAE,IAAIf,OAAO,CAACkB,uBAAuB,CAAC,CAAC,CAAC,CAC5DC,iBAAiB,CAAC,CAAC,CACnBC,mBAAmB,CAAC,CAAC,CACrBC,mBAAmB,CAAC,CAAC;IAExB,OAAOL,UAAU;EACnB,CAAC,CAAC,OAAOH,KAAK,EAAE;IACdF,OAAO,CAACE,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;IAC9C,OAAO,EAAE;EACX;AACF,CAAC;;AAED;AACA,OAAO,MAAMS,YAAY,GAAGA,CAACC,WAAW,EAAEC,WAAW,EAAEC,SAAS,GAAG,GAAG,KAAK;EACzE,IAAI,CAACF,WAAW,IAAI,CAACC,WAAW,EAAE,OAAO,KAAK;EAE9C,MAAME,QAAQ,GAAG1B,OAAO,CAAC2B,iBAAiB,CAACJ,WAAW,EAAEC,WAAW,CAAC;EACpE,OAAOE,QAAQ,GAAGD,SAAS;AAC7B,CAAC;;AAED;AACA,OAAO,MAAMG,aAAa,GAAGA,CAACC,cAAc,EAAEC,oBAAoB,KAAK;EACrE,IAAI,CAACD,cAAc,IAAI,CAACC,oBAAoB,CAACC,MAAM,EAAE,OAAO,IAAI;EAEhE,IAAIC,SAAS,GAAG,IAAI;EACpB,IAAIC,YAAY,GAAGC,MAAM,CAACC,iBAAiB;EAE3CL,oBAAoB,CAACM,OAAO,CAAEC,GAAG,IAAK;IACpC,MAAMX,QAAQ,GAAG1B,OAAO,CAAC2B,iBAAiB,CAACE,cAAc,EAAEQ,GAAG,CAAC;IAC/D,IAAIX,QAAQ,GAAGO,YAAY,EAAE;MAC3BA,YAAY,GAAGP,QAAQ;MACvBM,SAAS,GAAG;QAAEN,QAAQ;QAAEY,KAAK,EAAER,oBAAoB,CAACS,OAAO,CAACF,GAAG;MAAE,CAAC;IACpE;EACF,CAAC,CAAC;EAEF,OAAOL,SAAS,IAAIA,SAAS,CAACN,QAAQ,GAAG,GAAG,GAAGM,SAAS,GAAG,IAAI;AACjE,CAAC;;AAED;AACA,OAAO,MAAMQ,iBAAiB,GAAIC,UAAU,IAAK;EAC/C,OAAOC,KAAK,CAACC,IAAI,CAACF,UAAU,CAAC;AAC/B,CAAC;;AAED;AACA,OAAO,MAAMG,iBAAiB,GAAIC,KAAK,IAAK;EAC1C,OAAO,IAAIC,YAAY,CAACD,KAAK,CAAC;AAChC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}