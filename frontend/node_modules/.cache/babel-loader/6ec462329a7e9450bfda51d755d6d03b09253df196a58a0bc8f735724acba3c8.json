{"ast":null,"code":"// Import face-api.js library\nimport*as faceapi from\"@vladmandic/face-api\";// Face-api.js utilities for face recognition\nexport const loadFaceApiModels=async()=>{const MODEL_URL=\"https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.14/model/\";try{await Promise.all([faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL)]);console.log(\"Face API models loaded successfully\");return true;}catch(error){console.error(\"Error loading Face API models:\",error);return false;}};// Detect faces in an image\nexport const detectFaces=async input=>{try{const detections=await faceapi.detectAllFaces(input,new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptors().withFaceExpressions();return detections;}catch(error){console.error(\"Error detecting faces:\",error);return[];}};// Compare two face descriptors with threshold\nexport const compareFaces=function(descriptor1,descriptor2){let threshold=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0.6;if(!descriptor1||!descriptor2)return false;const distance=faceapi.euclideanDistance(descriptor1,descriptor2);return distance<threshold;};// Find best matching face\nexport const findBestMatch=(faceDescriptor,referenceDescriptors)=>{if(!faceDescriptor||!referenceDescriptors.length)return null;let bestMatch=null;let bestDistance=Number.POSITIVE_INFINITY;referenceDescriptors.forEach(ref=>{const distance=faceapi.euclideanDistance(faceDescriptor,ref);if(distance<bestDistance){bestDistance=distance;bestMatch={distance,index:referenceDescriptors.indexOf(ref)};}});return bestMatch&&bestMatch.distance<0.6?bestMatch:null;};// Convert tensor to array\nexport const descriptorToArray=descriptor=>{return Array.from(descriptor);};// Convert array to tensor\nexport const arrayToDescriptor=array=>{return new Float32Array(array);};","map":{"version":3,"names":["faceapi","loadFaceApiModels","MODEL_URL","Promise","all","nets","tinyFaceDetector","loadFromUri","faceLandmark68Net","faceRecognitionNet","faceExpressionNet","console","log","error","detectFaces","input","detections","detectAllFaces","TinyFaceDetectorOptions","withFaceLandmarks","withFaceDescriptors","withFaceExpressions","compareFaces","descriptor1","descriptor2","threshold","arguments","length","undefined","distance","euclideanDistance","findBestMatch","faceDescriptor","referenceDescriptors","bestMatch","bestDistance","Number","POSITIVE_INFINITY","forEach","ref","index","indexOf","descriptorToArray","descriptor","Array","from","arrayToDescriptor","array","Float32Array"],"sources":["D:/we_project/face-recognition/v0-face-recognition-attendance/frontend/src/services/faceRecognition.js"],"sourcesContent":["// Import face-api.js library\r\nimport * as faceapi from \"@vladmandic/face-api\"\r\n\r\n// Face-api.js utilities for face recognition\r\nexport const loadFaceApiModels = async () => {\r\n  const MODEL_URL = \"https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.14/model/\"\r\n\r\n  try {\r\n    await Promise.all([\r\n      faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),\r\n      faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),\r\n      faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),\r\n      faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),\r\n    ])\r\n    console.log(\"Face API models loaded successfully\")\r\n    return true\r\n  } catch (error) {\r\n    console.error(\"Error loading Face API models:\", error)\r\n    return false\r\n  }\r\n}\r\n\r\n// Detect faces in an image\r\nexport const detectFaces = async (input) => {\r\n  try {\r\n    const detections = await faceapi\r\n      .detectAllFaces(input, new faceapi.TinyFaceDetectorOptions())\r\n      .withFaceLandmarks()\r\n      .withFaceDescriptors()\r\n      .withFaceExpressions()\r\n\r\n    return detections\r\n  } catch (error) {\r\n    console.error(\"Error detecting faces:\", error)\r\n    return []\r\n  }\r\n}\r\n\r\n// Compare two face descriptors with threshold\r\nexport const compareFaces = (descriptor1, descriptor2, threshold = 0.6) => {\r\n  if (!descriptor1 || !descriptor2) return false\r\n\r\n  const distance = faceapi.euclideanDistance(descriptor1, descriptor2)\r\n  return distance < threshold\r\n}\r\n\r\n// Find best matching face\r\nexport const findBestMatch = (faceDescriptor, referenceDescriptors) => {\r\n  if (!faceDescriptor || !referenceDescriptors.length) return null\r\n\r\n  let bestMatch = null\r\n  let bestDistance = Number.POSITIVE_INFINITY\r\n\r\n  referenceDescriptors.forEach((ref) => {\r\n    const distance = faceapi.euclideanDistance(faceDescriptor, ref)\r\n    if (distance < bestDistance) {\r\n      bestDistance = distance\r\n      bestMatch = { distance, index: referenceDescriptors.indexOf(ref) }\r\n    }\r\n  })\r\n\r\n  return bestMatch && bestMatch.distance < 0.6 ? bestMatch : null\r\n}\r\n\r\n// Convert tensor to array\r\nexport const descriptorToArray = (descriptor) => {\r\n  return Array.from(descriptor)\r\n}\r\n\r\n// Convert array to tensor\r\nexport const arrayToDescriptor = (array) => {\r\n  return new Float32Array(array)\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}